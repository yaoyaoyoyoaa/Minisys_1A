void main()
{
    int key_val;
    int key_status;
    int display_val; // 用一个变量来缓存整个数码管的值

    // 1. 初始化：直接写 32 位 0x88888888
    // 这样能一次性点亮所有数码管，验证显示功能
    $0xFFFFFC00 = 0x88888888; 

    while(1)
    {
        // 2. 读取键值 (地址也要对齐，建议只读 FC10)
        // 假设硬件把状态和键值都放在这个区域，或者我们要分开处理
        // 先读键值
        key_val = $0xfffffc10;
        
        // 读取状态 (注意：FC12 也是非对齐的，如果硬件不支持会有问题)
        // 建议：如果按键按下，key_val 通常是非 0 的 (除了按键0)
        // 或者我们可以尝试读 FC10 的高位? 
        // 但为了保险，我们先假设 key_status 能读到 (它是 lw，可能容忍度高一点，或者读到错位数据但非0)
        key_status = $0xfffffc12;

        // 3. 如果检测到按下，更新显示
        if (key_status != 0) 
        {
            // 拼凑 32 位数据：
            // 高 16 位：0x0001 (表示按下) -> 0x00010000
            // 低 16 位：key_val (键值)     -> 0x0000000X
            // 合成： 0x00010000 + key_val
            
            // 技巧：由于编译器对移位支持可能有限，直接用乘法
            // 0x0001 * 65536 = 0x10000
            display_val = 65536 + key_val;
            
            // 一次性写入对齐地址 FC00
            $0xFFFFFC00 = display_val;
        }
    }
}