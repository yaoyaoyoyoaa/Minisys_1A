/**
 * MiniC Compiler - Strict Compliance Version
 * 严格适配《Mini C的有关规定》
 * 1. 强制变量声明在函数开头
 * 2. 禁止 int a=1; 写法
 * 3. 支持 $ 端口操作符
 */

class MiniCCompiler {
    constructor() {
        this.labelCount = 0;
        this.regs = { ZERO: '$0', V0: '$2', V1: '$3', SP: '$29', TOP: '$30', RA: '$31' };
        this.varMap = {}; 
    }

    newLabel(prefix) { return `L_${prefix}_${this.labelCount++}`; }

    compile(ast) {
        let asm = "# Generated by MiniC Strict Compiler\n";
        // 自动初始化 SP 和 TOP (适配 BIOS)
        // asm += `  lui $sp, 0x0000\n  ori $sp, $sp, 0x7000\n  move $30, $sp\n  j main\n  nop\n`;
        ast.body.forEach(node => asm += this.genNode(node));
        return asm;
    }

    genNode(node) {
        if (!node) return "";
        switch (node.type) {
            case 'Program': return node.body.map(n => this.genNode(n)).join('');
            case 'FunctionDeclaration': return this.genFunction(node);
            case 'Block': return node.statements.map(s => this.genNode(s)).join('');
            case 'ReturnStatement': return this.genReturn(node);
            case 'Assignment': return this.genAssignment(node);
            case 'MemoryWrite': return this.genMemoryWrite(node); 
            case 'IfStatement': return this.genIf(node);
            case 'WhileStatement': return this.genWhile(node);
            case 'BinaryExpression': return this.genBinary(node);
            case 'UnaryExpression': return this.genUnary(node);
            case 'Literal': return `  li ${this.regs.V0}, ${node.value}\n`;
            case 'Variable': 
                if (this.varMap[node.name] === undefined) throw new Error(`Undefined variable: ${node.name}`);
                return `  lw ${this.regs.V0}, ${this.varMap[node.name]}(${this.regs.SP})\n`;
            default: return "";
        }
    }

    genFunction(node) {
        this.varMap = {}; 
        let stackSize = 0;
        
        // 1. 处理变量声明 (规定: 必须在开头)
        node.declarations.forEach(decl => {
            stackSize += 4;
            // 简单数组支持 (int a[10])
            if (decl.size && decl.size > 1) stackSize += (decl.size - 1) * 4;
            this.varMap[decl.name] = stackSize;
        });
        
        stackSize += 8; // RA + Old SP

        const funcName = node.name;
        let code = `\n${funcName}:\n`;
        code += `  sw ${this.regs.RA}, 0(${this.regs.TOP})\n`;
        code += `  sw ${this.regs.SP}, 4(${this.regs.TOP})\n`;
        code += `  move ${this.regs.SP}, ${this.regs.TOP}\n`;
        code += `  addi ${this.regs.TOP}, ${this.regs.TOP}, ${stackSize}\n`;
        
        // 2. 处理语句体
        code += this.genNode(node.body);
        
        code += `  move ${this.regs.TOP}, ${this.regs.SP}\n`;
        code += `  lw ${this.regs.RA}, 0(${this.regs.SP})\n`;
        code += `  lw ${this.regs.SP}, 4(${this.regs.SP})\n`;
        code += `  jr ${this.regs.RA}\n  nop\n`;
        return code;
    }

    genAssignment(node) {
        let code = this.genNode(node.value);
        code += `  sw ${this.regs.V0}, ${this.varMap[node.name]}(${this.regs.SP})\n`;
        return code;
    }

    genMemoryWrite(node) {
        // $addr = val
        let code = this.genNode(node.address); // 计算地址 -> V0
        code += `  sw ${this.regs.V0}, 0(${this.regs.TOP})\n`; // 暂存地址
        code += `  addi ${this.regs.TOP}, ${this.regs.TOP}, 4\n`;
        
        code += this.genNode(node.value); // 计算值 -> V0
        
        code += `  addi ${this.regs.TOP}, ${this.regs.TOP}, -4\n`;
        code += `  lw ${this.regs.V1}, 0(${this.regs.TOP})\n`; // 恢复地址 -> V1
        
        code += `  sw ${this.regs.V0}, 0(${this.regs.V1})\n`; // Store
        return code;
    }

    genIf(node) {
        const labelElse = this.newLabel('else');
        const labelEnd = this.newLabel('ifend');
        let code = this.genNode(node.test);
        code += `  beq ${this.regs.V0}, ${this.regs.ZERO}, ${labelElse}\n  nop\n`;
        code += this.genNode(node.consequent);
        code += `  j ${labelEnd}\n  nop\n`;
        code += `${labelElse}:\n`;
        if (node.alternate) code += this.genNode(node.alternate);
        code += `${labelEnd}:\n`;
        return code;
    }

    genWhile(node) {
        const labelLoop = this.newLabel('loop');
        const labelEnd = this.newLabel('endloop');
        let code = `${labelLoop}:\n`;
        code += this.genNode(node.test);
        code += `  beq ${this.regs.V0}, ${this.regs.ZERO}, ${labelEnd}\n  nop\n`;
        code += this.genNode(node.body);
        code += `  j ${labelLoop}\n  nop\n`;
        code += `${labelEnd}:\n`;
        return code;
    }

    genReturn(node) {
        let code = node.value ? this.genNode(node.value) : "";
        // 恢复栈并返回
        code += `  move ${this.regs.TOP}, ${this.regs.SP}\n`;
        code += `  lw ${this.regs.RA}, 0(${this.regs.SP})\n`;
        code += `  lw ${this.regs.SP}, 4(${this.regs.SP})\n`;
        code += `  jr ${this.regs.RA}\n  nop\n`;
        return code;
    }

    genUnary(node) {
        let code = this.genNode(node.argument);
        switch (node.operator) {
            case '$': // Read MMIO
                code += `  move ${this.regs.V1}, ${this.regs.V0}\n`;
                code += `  lw ${this.regs.V0}, 0(${this.regs.V1})\n`;
                break;
            case '-': code += `  sub ${this.regs.V0}, ${this.regs.ZERO}, ${this.regs.V0}\n`; break;
            case '!': code += `  sltiu ${this.regs.V0}, ${this.regs.V0}, 1\n`; break;
            case '~': code += `  nor ${this.regs.V0}, ${this.regs.V0}, ${this.regs.ZERO}\n`; break;
        }
        return code;
    }

    genBinary(node) {
        let code = this.genNode(node.left);
        code += `  sw ${this.regs.V0}, 0(${this.regs.TOP})\n`; // Push left
        code += `  addi ${this.regs.TOP}, ${this.regs.TOP}, 4\n`;
        code += this.genNode(node.right); // Right -> V0
        code += `  addi ${this.regs.TOP}, ${this.regs.TOP}, -4\n`;
        code += `  lw ${this.regs.V1}, 0(${this.regs.TOP})\n`; // Pop left -> V1
        
        switch (node.operator) {
            case '+': code += `  add ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '-': code += `  sub ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '*': code += `  mult ${this.regs.V1}, ${this.regs.V0}\n  mflo ${this.regs.V0}\n`; break;
            case '&': code += `  and ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '|': code += `  or ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '^': code += `  xor ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '<<': code += `  sllv ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '>>': code += `  srlv ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '<': code += `  slt ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '>': code += `  slt ${this.regs.V0}, ${this.regs.V0}, ${this.regs.V1}\n`; break;
            case '==': 
                code += `  xor ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`;
                code += `  sltiu ${this.regs.V0}, ${this.regs.V0}, 1\n`;
                break;
            case '!=':
                code += `  xor ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`;
                code += `  sltu ${this.regs.V0}, ${this.regs.ZERO}, ${this.regs.V0}\n`;
                break;
        }
        return code;
    }
}

// --- Tokenizer ---
function tokenize(source) {
    // 移除注释
    source = source.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '');
    const regex = /\s*(0x[0-9a-fA-F]+|[0-9]+|int|return|if|else|while|\$|[a-zA-Z_][a-zA-Z0-9_]*|[+\-*/%&|^<>=!~]+|[(){};\[\]])\s*/g;
    let tokens = [];
    let match;
    while ((match = regex.exec(source)) !== null) {
        if (match[1]) tokens.push(match[1]);
    }
    return tokens;
}

// --- Strict Parser ---
class Parser {
    constructor(tokens) { this.tokens = tokens; this.pos = 0; }
    peek() { return this.tokens[this.pos]; }
    consume() { return this.tokens[this.pos++]; }
    match(str) { if (this.peek() === str) { this.pos++; return true; } return false; }
    expect(str) { if (this.consume() !== str) throw new Error(`Expected '${str}' at token ${this.pos}`); }

    parseProgram() {
        let funcs = [];
        // 自动包裹 main 如果没有函数定义 (兼容旧代码)
        if (!this.tokens.includes('void') && !this.tokens.includes('int')) {
             return { type: 'Program', body: [{
                type: 'FunctionDeclaration', name: 'main', 
                declarations: [],
                body: { type: 'Block', statements: this.parseBlockContent() }
            }]};
        }

        while(this.pos < this.tokens.length) {
            // 解析函数: type name() { decls... stmts... }
            this.consume(); // type (void/int)
            let name = this.consume();
            this.expect('('); 
            while(this.peek() !== ')') this.consume(); // 跳过参数
            this.expect(')');
            this.expect('{');
            
            // 1. 严格解析变量声明区
            let decls = [];
            while (this.match('int')) {
                let varName = this.consume();
                let size = 1;
                if (this.match('[')) {
                    size = parseInt(this.consume());
                    this.expect(']');
                }
                // 检查非法初始化
                if (this.peek() === '=') throw new Error(`Illegal Syntax: Variable '${varName}' initialization forbidden in declaration.`);
                this.expect(';');
                decls.push({ name: varName, size });
            }

            // 2. 解析语句区
            let stmts = this.parseBlockContent();
            this.expect('}');
            
            funcs.push({ type: 'FunctionDeclaration', name, declarations: decls, body: { type: 'Block', statements: stmts } });
        }
        return { type: 'Program', body: funcs };
    }

    parseBlockContent() {
        let stmts = [];
        while (this.peek() !== '}' && this.pos < this.tokens.length) {
            if (this.peek() === 'int') throw new Error("Illegal Syntax: Variable declarations must be at the beginning of the function.");
            stmts.push(this.parseStatement());
        }
        return stmts;
    }

    parseStatement() {
        if (this.match('return')) {
            let value = (this.peek() !== ';') ? this.parseExpression() : null;
            this.expect(';');
            return { type: 'ReturnStatement', value };
        }
        if (this.match('if')) {
            this.expect('('); let test = this.parseExpression(); this.expect(')');
            this.expect('{'); let consequent = { type: 'Block', statements: this.parseBlockContent() }; this.expect('}');
            let alternate = null;
            if (this.match('else')) {
                this.expect('{'); alternate = { type: 'Block', statements: this.parseBlockContent() }; this.expect('}');
            }
            return { type: 'IfStatement', test, consequent, alternate };
        }
        if (this.match('while')) {
            this.expect('('); let test = this.parseExpression(); this.expect(')');
            this.expect('{'); let body = { type: 'Block', statements: this.parseBlockContent() }; this.expect('}');
            return { type: 'WhileStatement', test, body };
        }
        
        // 表达式语句
        let expr = this.parseExpression();
        this.expect(';');
        return expr;
    }

    parseExpression() { return this.parseAssignment(); }

    parseAssignment() {
        let left = this.parseLogical();
        if (this.match('=')) {
            let right = this.parseAssignment();
            if (left.type === 'Variable') return { type: 'Assignment', name: left.name, value: right };
            if (left.type === 'UnaryExpression' && left.operator === '$') return { type: 'MemoryWrite', address: left.argument, value: right };
            throw new Error("Invalid l-value assignment");
        }
        return left;
    }

    parseLogical() { return this.parseCompare(); } // 简化优先级
    parseCompare() {
        let left = this.parseAddSub();
        while (['==','!=','<','>'].includes(this.peek())) {
            let op = this.consume();
            let right = this.parseAddSub();
            left = { type: 'BinaryExpression', operator: op, left, right };
        }
        return left;
    }
    parseAddSub() {
        let left = this.parseTerm();
        while (['+','-','|','&','^','<<','>>'].includes(this.peek())) {
            let op = this.consume();
            let right = this.parseTerm();
            left = { type: 'BinaryExpression', operator: op, left, right };
        }
        return left;
    }
    parseTerm() {
        let left = this.parseFactor();
        while (['*','/','%'].includes(this.peek())) {
            let op = this.consume();
            let right = this.parseFactor();
            left = { type: 'BinaryExpression', operator: op, left, right };
        }
        return left;
    }
    parseFactor() {
        if (this.match('(')) { let e = this.parseExpression(); this.expect(')'); return e; }
        if (this.match('$')) return { type: 'UnaryExpression', operator: '$', argument: this.parseFactor() };
        if (this.match('-')) return { type: 'UnaryExpression', operator: '-', argument: this.parseFactor() };
        if (this.match('!')) return { type: 'UnaryExpression', operator: '!', argument: this.parseFactor() };
        if (this.match('~')) return { type: 'UnaryExpression', operator: '~', argument: this.parseFactor() };
        
        let t = this.consume();
        if (/^0x/.test(t)) return { type: 'Literal', value: parseInt(t, 16) };
        if (/^[0-9]+$/.test(t)) return { type: 'Literal', value: parseInt(t) };
        if (/^[a-zA-Z_]/.test(t)) return { type: 'Variable', name: t };
        throw new Error(`Unexpected token: ${t}`);
    }
}

module.exports = { 
    compile: (source) => {
        const tokens = tokenize(source);
        const parser = new Parser(tokens);
        const ast = parser.parseProgram();
        const compiler = new MiniCCompiler();
        return compiler.compile(ast); 
    } 
};