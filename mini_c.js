/**
 * MiniC 编译器核心实现 - src/main.js
 * 适配：向上生长的栈帧、端口访问、32位 MIPS 核心指令集
 */

class MiniCCompiler {
    constructor() {
        this.labelCount = 0;
        // 寄存器分配约定
        this.regs = {
            ZERO: '$0',
            V0:   '$2',  // 表达式结果
            V1:   '$3',  // 辅助/端口操作
            SP:   '$29', // 活动记录底部指针
            TOP:  '$30', // 活动记录顶端指针（向上生长）
            RA:   '$31'  // 返回地址
        };
    }

    // 生成唯一跳转标签
    newLabel(prefix) {
        return `L_${prefix}_${this.labelCount++}`;
    }

    /**
     * 代码生成主入口
     * @param {Object} ast 语法分析器生成的树状结构
     */
    compile(ast) {
        let asm = "; Generated by MiniC Compiler for MiniSys-1A\n";
        if (ast.type === 'Program') {
            ast.body.forEach(node => {
                asm += this.genNode(node);
            });
        }
        return asm;
    }

    genNode(node) {
        switch (node.type) {
            case 'FunctionDeclaration':
                return this.genFunction(node);
            case 'Block':
                return node.statements.map(s => this.genNode(s)).join('');
            case 'IfStatement':
                return this.genIf(node);
            case 'WhileStatement':
                return this.genWhile(node);
            case 'ReturnStatement':
                return this.genReturn(node);
            case 'Assignment':
                return this.genAssignment(node);
            case 'ExpressionStatement':
                return this.genNode(node.expression);
            case 'BinaryExpression':
                return this.genBinary(node);
            case 'PortAccess': // 处理 $expr 语法
                return this.genPortAccess(node);
            case 'Literal':
                return `  addi ${this.regs.V0}, ${this.regs.ZERO}, ${node.value}\n`;
            case 'Variable':
                return `  lw ${this.regs.V0}, ${node.offset}(${this.regs.SP}) ; Load local var\n`;
            default:
                return `; Unknown node type: ${node.type}\n`;
        }
    }

    // --- 核心逻辑处理 ---

    genFunction(node) {
        const funcName = node.name.toUpperCase();
        let code = `\n${funcName}:\n`;
        // 1. 进入函数：建立向上生长的活动记录 (讲义 P122)
        code += `  sw ${this.regs.RA}, 0(${this.regs.TOP})    ; Save RA\n`;
        code += `  sw ${this.regs.SP}, 4(${this.regs.TOP})    ; Save old SP\n`;
        code += `  move ${this.regs.SP}, ${this.regs.TOP}     ; SP = TOP\n`;
        code += `  addi ${this.regs.TOP}, ${this.regs.TOP}, ${node.stackSize || 32} ; TOP 向上生长\n`;

        // 2. 生成函数体代码
        code += this.genNode(node.body);

        // 3. 默认返回逻辑（防止漏写 return）
        code += `  move ${this.regs.TOP}, ${this.regs.SP}     ; 释放栈空间\n`;
        code += `  lw ${this.regs.RA}, 0(${this.regs.SP})    ; Restore RA\n`;
        code += `  lw ${this.regs.SP}, 4(${this.regs.SP})    ; Restore old SP\n`;
        code += `  jr ${this.regs.RA}\n`;
        return code;
    }

    genAssignment(node) {
        let code = this.genNode(node.value); // 计算表达式，结果在 $v0
        if (node.isPort) {
            // 如果是赋值给端口地址
            code += `  addi ${this.regs.V1}, ${this.regs.ZERO}, ${node.address}\n`;
            code += `  sw ${this.regs.V0}, 0(${this.regs.V1})   ; Port Write\n`;
        } else {
            // 存入局部变量（基于 SP 的偏移）
            code += `  sw ${this.regs.V0}, ${node.offset}(${this.regs.SP})\n`;
        }
        return code;
    }

    genPortAccess(node) {
        // 实现 $ expr 语法 (讲义 P127)
        let code = this.genNode(node.expr); // 地址入 $v0
        code += `  lw ${this.regs.V0}, 0(${this.regs.V0})     ; Port Read\n`;
        return code;
    }

    genIf(node) {
        const labelElse = this.newLabel('else');
        const labelEnd = this.newLabel('ifend');
        let code = this.genNode(node.test);
        code += `  beq ${this.regs.V0}, ${this.regs.ZERO}, ${labelElse}\n`;
        code += this.genNode(node.consequent);
        code += `  j ${labelEnd}\n`;
        code += `${labelElse}:\n`;
        if (node.alternate) code += this.genNode(node.alternate);
        code += `${labelEnd}:\n`;
        return code;
    }

    genBinary(node) {
        // 简单的寄存器压力处理（实际应用建议用栈暂存）
        let code = this.genNode(node.left);
        code += `  move ${this.regs.V1}, ${this.regs.V0}\n`; // 左值移至辅助寄存器
        code += this.genNode(node.right);                  // 右值在 $v0
        
        switch (node.operator) {
            case '+': code += `  add ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '-': code += `  sub ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '&': code += `  and ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '|': code += `  or ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
        }
        return code;
    }

    genReturn(node) {
        let code = node.value ? this.genNode(node.value) : "";
        code += `  move ${this.regs.TOP}, ${this.regs.SP}     ; 回收栈顶\n`;
        code += `  lw ${this.regs.RA}, 0(${this.regs.SP})\n`;
        code += `  lw ${this.regs.SP}, 4(${this.regs.SP})\n`;
        code += `  jr ${this.regs.RA}\n`;
        return code;
    }
}

function simpleParse(source) {
    const retMatch = source.match(/return\s+(\w+);/);
    const retVar = retMatch ? retMatch[1] : '0';
    const statements = [];
    let stackPtr = 8; // 0=RA, 4=OldSP
    const varMap = {};

    function getOffset(name) {
        if (!varMap[name]) { stackPtr+=4; varMap[name] = stackPtr; }
        return varMap[name];
    }

    source.split('\n').forEach(line => {
        line = line.trim();
        if (line.startsWith('int ')) {
            const parts = line.match(/int\s+(\w+)\s*=\s*(.+);/);
            if (parts) {
                const name = parts[1];
                const rhs = parts[2].trim();
                let exprNode;
                if (rhs.includes('+') || rhs.includes('-')) {
                    const op = rhs.includes('+') ? '+' : '-';
                    const [l, r] = rhs.split(op).map(s=>s.trim());
                    exprNode = { 
                        type: 'BinaryExpression', operator: op,
                        left: {type:'Variable', offset: getOffset(l)},
                        right:{type:'Variable', offset: getOffset(r)}
                    };
                } else {
                    exprNode = {type:'Literal', value: parseInt(rhs)};
                }
                statements.push({ type: 'Assignment', offset: getOffset(name), value: exprNode });
            }
        }
    });

    statements.push({ type: 'ReturnStatement', value: {type:'Variable', offset: varMap[retVar]||0} });

    return { type: 'Program', body: [{
        type: 'FunctionDeclaration', name: 'main', stackSize: 32,
        body: { type: 'Block', statements: statements }
    }]};
}

module.exports = { 
    compile: (source) => {
        const ast = simpleParse(source); 
        const compiler = new MiniCCompiler();
        return compiler.compile(ast); 
    } 
};