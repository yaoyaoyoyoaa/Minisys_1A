/**
 * MiniC Compiler Pro - Minisys-1A Hardware Adapted Version
 * * 更新日志:
 * 1. 新增 '$' 运算符支持 MMIO 端口直接读写 (符合 Mini C 规范)
 * 2. 完善解析器：支持 hex 常量、while 循环、变量赋值、代码块
 * 3. 优化代码生成：适配 32 位地址操作
 */

class MiniCCompiler {
    constructor() {
        this.labelCount = 0;
        // 寄存器约定: V0($2)用于返回值/表达式结果, V1($3)用于辅助
        this.regs = {
            ZERO: '$0', V0: '$2', V1: '$3', 
            SP: '$29', TOP: '$30', RA: '$31'
        };
        this.varMap = {}; // 变量映射 {name: offset}
    }

    newLabel(prefix) { return `L_${prefix}_${this.labelCount++}`; }

    compile(ast) {
        let asm = "# Generated by MiniC Compiler Pro (Hardware Edition)\n";
        // 简单的内置头部，确保 main 被调用 (配合 BIOS 使用时可忽略，但为了完整性保留)
        // asm += "  j main\n  nop\n"; 
        
        if (ast.type === 'Program') {
            ast.body.forEach(node => asm += this.genNode(node));
        }
        return asm;
    }

    genNode(node) {
        if (!node) return "";
        switch (node.type) {
            case 'FunctionDeclaration': return this.genFunction(node);
            case 'Block': return node.statements.map(s => this.genNode(s)).join('');
            case 'ReturnStatement': return this.genReturn(node);
            case 'VariableDeclaration': return this.genVarDecl(node);
            case 'Assignment': return this.genAssignment(node);
            case 'MemoryWrite': return this.genMemoryWrite(node); // 处理 $addr = val
            case 'IfStatement': return this.genIf(node);
            case 'WhileStatement': return this.genWhile(node);
            case 'BinaryExpression': return this.genBinary(node);
            case 'UnaryExpression': return this.genUnary(node);
            case 'Literal': 
                // 支持大数(32位)，使用 LI 伪指令，汇编器会转为 LUI+ORI
                return `  li ${this.regs.V0}, ${node.value}\n`;
            case 'Variable': 
                if (this.varMap[node.name] === undefined) throw new Error(`Undefined variable: ${node.name}`);
                return `  lw ${this.regs.V0}, ${this.varMap[node.name]}(${this.regs.SP})\n`;
            default: return `# Unknown node type: ${node.type}\n`;
        }
    }

    genFunction(node) {
        this.varMap = {}; // 重置变量表
        let stackSize = 0;
        
        // 预扫描计算栈空间 (简化处理：每个声明分配4字节)
        const scanVars = (n) => {
            if (n.type === 'VariableDeclaration') {
                stackSize += 4;
                this.varMap[n.name] = stackSize; // 这里的 offset 是相对于 SP 初始值的正向偏移，或者是相对于新 SP 的？
                // 修正：MiniSys BIOS 设置 SP 向高地址增长 (TOP 指针)
                // 这里的实现沿用之前的约定：TOP($30) 是栈顶，SP($29) 是栈底
                // 变量存在 SP + offset 处
            }
            if (n.body) scanVars(n.body);
            if (n.statements) n.statements.forEach(scanVars);
            if (n.consequent) scanVars(n.consequent);
            if (n.alternate) scanVars(n.alternate);
        };
        scanVars(node.body);
        stackSize += 8; // RA + Old SP

        const funcName = node.name; // main 不转大写，保持原样
        let code = `\n${funcName}:\n`;
        // 保存上下文
        code += `  sw ${this.regs.RA}, 0(${this.regs.TOP})\n`;
        code += `  sw ${this.regs.SP}, 4(${this.regs.TOP})\n`;
        code += `  move ${this.regs.SP}, ${this.regs.TOP}\n`;
        code += `  addi ${this.regs.TOP}, ${this.regs.TOP}, ${stackSize}\n`;
        
        code += this.genNode(node.body);
        
        // 默认返回 (防止函数末尾没有 return)
        code += `  move ${this.regs.TOP}, ${this.regs.SP}\n`;
        code += `  lw ${this.regs.RA}, 0(${this.regs.SP})\n`;
        code += `  lw ${this.regs.SP}, 4(${this.regs.SP})\n`;
        code += `  jr ${this.regs.RA}\n`;
        return code;
    }

    genVarDecl(node) {
        // int a = expr;
        let code = "";
        if (node.init) {
            code += this.genNode(node.init); // Result in V0
            code += `  sw ${this.regs.V0}, ${this.varMap[node.name]}(${this.regs.SP})\n`;
        }
        return code;
    }

    genAssignment(node) {
        // a = expr;
        let code = this.genNode(node.value);
        code += `  sw ${this.regs.V0}, ${this.varMap[node.name]}(${this.regs.SP})\n`;
        return code;
    }

    genMemoryWrite(node) {
        // $addr = val; (MMIO Write)
        // 1. 计算地址 -> V0
        let code = this.genNode(node.address); 
        // 2. 保护地址 (压栈)
        code += `  sw ${this.regs.V0}, 0(${this.regs.TOP})\n`; 
        code += `  addi ${this.regs.TOP}, ${this.regs.TOP}, 4\n`;
        // 3. 计算值 -> V0
        code += this.genNode(node.value);
        // 4. 恢复地址 -> V1
        code += `  addi ${this.regs.TOP}, ${this.regs.TOP}, -4\n`;
        code += `  lw ${this.regs.V1}, 0(${this.regs.TOP})\n`;
        // 5. 写入内存: sw val($v0), 0(addr($v1))
        code += `  sw ${this.regs.V0}, 0(${this.regs.V1})\n`;
        return code;
    }

    genIf(node) {
        const labelElse = this.newLabel('else');
        const labelEnd = this.newLabel('ifend');
        let code = this.genNode(node.test);
        code += `  beq ${this.regs.V0}, ${this.regs.ZERO}, ${labelElse}\n`;
        code += `  nop\n`; // 延迟槽
        code += this.genNode(node.consequent);
        code += `  j ${labelEnd}\n  nop\n`;
        code += `${labelElse}:\n`;
        if (node.alternate) code += this.genNode(node.alternate);
        code += `${labelEnd}:\n`;
        return code;
    }

    genWhile(node) {
        const labelLoop = this.newLabel('loop');
        const labelEnd = this.newLabel('endloop');
        let code = `${labelLoop}:\n`;
        code += this.genNode(node.test);
        code += `  beq ${this.regs.V0}, ${this.regs.ZERO}, ${labelEnd}\n  nop\n`;
        code += this.genNode(node.body);
        code += `  j ${labelLoop}\n  nop\n`;
        code += `${labelEnd}:\n`;
        return code;
    }

    genReturn(node) {
        let code = node.value ? this.genNode(node.value) : "";
        code += `  move ${this.regs.TOP}, ${this.regs.SP}\n`;
        code += `  lw ${this.regs.RA}, 0(${this.regs.SP})\n`;
        code += `  lw ${this.regs.SP}, 4(${this.regs.SP})\n`;
        code += `  jr ${this.regs.RA}\n  nop\n`;
        return code;
    }

    genUnary(node) {
        let code = this.genNode(node.argument); // Result in V0
        switch (node.operator) {
            case '$': // MMIO Read: lw $v0, 0($v0)
                code += `  move ${this.regs.V1}, ${this.regs.V0}\n`;
                code += `  lw ${this.regs.V0}, 0(${this.regs.V1})\n`;
                break;
            case '-':
                code += `  sub ${this.regs.V0}, ${this.regs.ZERO}, ${this.regs.V0}\n`;
                break;
            case '!':
                code += `  sltiu ${this.regs.V0}, ${this.regs.V0}, 1\n`;
                break;
            case '~':
                code += `  nor ${this.regs.V0}, ${this.regs.V0}, ${this.regs.ZERO}\n`;
                break;
        }
        return code;
    }

    genBinary(node) {
        let code = this.genNode(node.left);
        // Push left operand
        code += `  sw ${this.regs.V0}, 0(${this.regs.TOP})\n`;
        code += `  addi ${this.regs.TOP}, ${this.regs.TOP}, 4\n`;
        
        code += this.genNode(node.right);
        // Pop left operand to V1
        code += `  addi ${this.regs.TOP}, ${this.regs.TOP}, -4\n`;
        code += `  lw ${this.regs.V1}, 0(${this.regs.TOP})\n`;
        
        switch (node.operator) {
            case '+': code += `  add ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '-': code += `  sub ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '*': code += `  mult ${this.regs.V1}, ${this.regs.V0}\n  mflo ${this.regs.V0}\n`; break;
            case '/': code += `  div ${this.regs.V1}, ${this.regs.V0}\n  mflo ${this.regs.V0}\n`; break;
            case '%': code += `  div ${this.regs.V1}, ${this.regs.V0}\n  mfhi ${this.regs.V0}\n`; break;
            case '&': code += `  and ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '|': code += `  or ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '^': code += `  xor ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '<<': code += `  sllv ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '>>': code += `  srlv ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            // 关系运算
            case '==': 
                code += `  xor ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`;
                code += `  sltiu ${this.regs.V0}, ${this.regs.V0}, 1\n`; // if diff<1 (0) then 1 else 0
                break;
            case '!=':
                code += `  xor ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`;
                code += `  sltu ${this.regs.V0}, ${this.regs.ZERO}, ${this.regs.V0}\n`;
                break;
            case '<': code += `  slt ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '>': code += `  slt ${this.regs.V0}, ${this.regs.V0}, ${this.regs.V1}\n`; break; // swap args
        }
        return code;
    }
}

// --- 增强版 Parser (支持 Hex, $, While) ---
function tokenize(source) {
    // 匹配: hex, decimal, keywords, operators, brackets, identifiers
    const regex = /\s*(0x[0-9a-fA-F]+|[0-9]+|int|return|if|else|while|\$|[a-zA-Z_][a-zA-Z0-9_]*|[+\-*/%&|^<>=!~]+|[(){};\[\]])\s*/g;
    let tokens = [];
    let match;
    while ((match = regex.exec(source)) !== null) {
        if (match[1]) tokens.push(match[1]);
    }
    return tokens;
}

class Parser {
    constructor(tokens) { this.tokens = tokens; this.pos = 0; }
    peek() { return this.tokens[this.pos]; }
    consume() { return this.tokens[this.pos++]; }
    match(str) { if (this.peek() === str) { this.pos++; return true; } return false; }
    expect(str) { if (this.consume() !== str) throw new Error(`Expected ${str}`); }

    parseProgram() {
        // 如果没有 main，自动包裹 (向后兼容)
        if (!this.tokens.includes('main')) {
            return { type: 'Program', body: [{
                type: 'FunctionDeclaration', name: 'main',
                body: { type: 'Block', statements: this.parseBlockContent() }
            }]};
        }
        let funcs = [];
        while(this.pos < this.tokens.length) {
            if (this.match('int')) {
                let name = this.consume();
                this.expect('('); this.expect(')'); 
                let body = this.parseBlock();
                funcs.push({ type: 'FunctionDeclaration', name, body });
            } else break;
        }
        return { type: 'Program', body: funcs };
    }

    parseBlock() {
        this.expect('{');
        let stmts = this.parseBlockContent();
        this.expect('}');
        return { type: 'Block', statements: stmts };
    }
    
    parseBlockContent() {
        let stmts = [];
        while (this.peek() !== '}' && this.pos < this.tokens.length) {
            stmts.push(this.parseStatement());
        }
        return stmts;
    }

    parseStatement() {
        if (this.match('int')) {
            let name = this.consume();
            let init = null;
            if (this.match('=')) init = this.parseExpression();
            this.expect(';');
            return { type: 'VariableDeclaration', name, init };
        }
        if (this.match('return')) {
            let value = this.parseExpression();
            this.expect(';');
            return { type: 'ReturnStatement', value };
        }
        if (this.match('if')) {
            this.expect('('); let test = this.parseExpression(); this.expect(')');
            let consequent = this.parseBlock();
            let alternate = null;
            if (this.match('else')) alternate = this.parseBlock();
            return { type: 'IfStatement', test, consequent, alternate };
        }
        if (this.match('while')) {
            this.expect('('); let test = this.parseExpression(); this.expect(')');
            let body = this.parseBlock();
            return { type: 'WhileStatement', test, body };
        }
        
        // 表达式语句 (赋值或 $写)
        let expr = this.parseExpression();
        this.expect(';');
        
        // 检查是否是赋值: AST node hacking
        // 如果 expr 是 Assignment (在 parseExpression 中处理优先级太乱，这里简化处理)
        // 实际上 parseExpression 应该处理赋值
        return expr;
    }

    parseExpression() {
        return this.parseAssignment();
    }

    parseAssignment() {
        let left = this.parseLogical();
        if (this.match('=')) {
            let right = this.parseAssignment(); // Right associative
            if (left.type === 'Variable') {
                return { type: 'Assignment', name: left.name, value: right };
            } else if (left.type === 'UnaryExpression' && left.operator === '$') {
                return { type: 'MemoryWrite', address: left.argument, value: right };
            }
            throw new Error("Invalid l-value assignment");
        }
        return left;
    }

    // 优先级层级...
    parseLogical() { return this.parseBitwise(); } // 简化：混用
    parseBitwise() { return this.parseCompare(); }
    
    parseCompare() {
        let left = this.parseAddSub();
        while (['==','!=','<','>','<=','>='].includes(this.peek())) {
            let op = this.consume();
            let right = this.parseAddSub();
            left = { type: 'BinaryExpression', operator: op, left, right };
        }
        return left;
    }

    parseAddSub() {
        let left = this.parseTerm();
        while (['+','-','|','^'].includes(this.peek())) {
            let op = this.consume();
            let right = this.parseTerm();
            left = { type: 'BinaryExpression', operator: op, left, right };
        }
        return left;
    }

    parseTerm() {
        let left = this.parseFactor();
        while (['*','/','%','&','<<','>>'].includes(this.peek())) {
            let op = this.consume();
            let right = this.parseFactor();
            left = { type: 'BinaryExpression', operator: op, left, right };
        }
        return left;
    }

    parseFactor() {
        if (this.match('(')) {
            let expr = this.parseExpression();
            this.expect(')');
            return expr;
        }
        if (this.match('$')) {
            return { type: 'UnaryExpression', operator: '$', argument: this.parseFactor() };
        }
        if (this.match('-')) {
            return { type: 'UnaryExpression', operator: '-', argument: this.parseFactor() };
        }
        if (this.match('!')) {
            return { type: 'UnaryExpression', operator: '!', argument: this.parseFactor() };
        }
        if (this.match('~')) {
            return { type: 'UnaryExpression', operator: '~', argument: this.parseFactor() };
        }
        
        let token = this.consume();
        if (/^[0-9]+$/.test(token)) return { type: 'Literal', value: parseInt(token) };
        if (/^0x[0-9a-fA-F]+$/.test(token)) return { type: 'Literal', value: parseInt(token, 16) }; // Hex
        if (/^[a-zA-Z_]/.test(token)) return { type: 'Variable', name: token };
        
        throw new Error(`Unexpected token: ${token}`);
    }
}

module.exports = { 
    compile: (source) => {
        const tokens = tokenize(source);
        const parser = new Parser(tokens);
        const ast = parser.parseProgram();
        const compiler = new MiniCCompiler();
        return compiler.compile(ast); 
    } 
};