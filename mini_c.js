/**
 * MiniC 编译器核心实现 - Pro Version
 * 适配：Step 3 增加的乘除法单元 (HILO)
 */

class MiniCCompiler {
    constructor() {
        this.labelCount = 0;
        this.regs = {
            ZERO: '$0', V0: '$2', V1: '$3', SP: '$29', TOP: '$30', RA: '$31'
        };
    }

    newLabel(prefix) { return `L_${prefix}_${this.labelCount++}`; }

    compile(ast) {
        let asm = "; Generated by MiniC Compiler Pro\n";
        if (ast.type === 'Program') ast.body.forEach(node => asm += this.genNode(node));
        return asm;
    }

    genNode(node) {
        switch (node.type) {
            case 'FunctionDeclaration': return this.genFunction(node);
            case 'Block': return node.statements.map(s => this.genNode(s)).join('');
            case 'ReturnStatement': return this.genReturn(node);
            case 'Assignment': return this.genAssignment(node);
            case 'BinaryExpression': return this.genBinary(node);
            case 'Literal': return `  addi ${this.regs.V0}, ${this.regs.ZERO}, ${node.value}\n`;
            case 'Variable': return `  lw ${this.regs.V0}, ${node.offset}(${this.regs.SP})\n`;
            case 'IfStatement': return this.genIf(node); // (需原有逻辑支持，此处略简)
            default: return `; Unknown node type: ${node.type}\n`;
        }
    }

    genFunction(node) {
        // ... (保持原有逻辑: 保存 RA, SP, 移动 TOP) ...
        const funcName = node.name.toUpperCase();
        let code = `\n${funcName}:\n`;
        code += `  sw ${this.regs.RA}, 0(${this.regs.TOP})\n`;
        code += `  sw ${this.regs.SP}, 4(${this.regs.TOP})\n`;
        code += `  move ${this.regs.SP}, ${this.regs.TOP}\n`;
        code += `  addi ${this.regs.TOP}, ${this.regs.TOP}, ${node.stackSize || 32}\n`;
        code += this.genNode(node.body);
        code += `  move ${this.regs.TOP}, ${this.regs.SP}\n`;
        code += `  lw ${this.regs.RA}, 0(${this.regs.SP})\n`;
        code += `  lw ${this.regs.SP}, 4(${this.regs.SP})\n`;
        code += `  jr ${this.regs.RA}\n`;
        return code;
    }

    genAssignment(node) {
        let code = this.genNode(node.value);
        code += `  sw ${this.regs.V0}, ${node.offset}(${this.regs.SP})\n`;
        return code;
    }
    
    genIf(node) {
        const labelElse = this.newLabel('else');
        const labelEnd = this.newLabel('ifend');
        let code = this.genNode(node.test);
        code += `  beq ${this.regs.V0}, ${this.regs.ZERO}, ${labelElse}\n`;
        code += this.genNode(node.consequent);
        code += `  j ${labelEnd}\n`;
        code += `${labelElse}:\n`;
        if (node.alternate) code += this.genNode(node.alternate);
        code += `${labelEnd}:\n`;
        return code;
    }
    
    genReturn(node) {
        let code = node.value ? this.genNode(node.value) : "";
        code += `  move ${this.regs.TOP}, ${this.regs.SP}\n`;
        code += `  lw ${this.regs.RA}, 0(${this.regs.SP})\n`;
        code += `  lw ${this.regs.SP}, 4(${this.regs.SP})\n`;
        code += `  jr ${this.regs.RA}\n`;
        return code;
    }

    // --- 重点修改：支持更多运算符 ---
    genBinary(node) {
        let code = this.genNode(node.left);
        code += `  move ${this.regs.V1}, ${this.regs.V0}\n`; // 左操作数 -> V1
        code += this.genNode(node.right);                  // 右操作数 -> V0
        
        // V1 op V0
        switch (node.operator) {
            case '+': code += `  add ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '-': code += `  sub ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            
            // [新增] 乘除法
            case '*': 
                code += `  mult ${this.regs.V1}, ${this.regs.V0}\n`; 
                code += `  mflo ${this.regs.V0}\n`; // 结果取 LO
                break;
            case '/': 
                code += `  div ${this.regs.V1}, ${this.regs.V0}\n`; 
                code += `  mflo ${this.regs.V0}\n`; // 商取 LO
                break;
            case '%': 
                code += `  div ${this.regs.V1}, ${this.regs.V0}\n`; 
                code += `  mfhi ${this.regs.V0}\n`; // 余数取 HI
                break;

            // [新增] 逻辑运算
            case '&': code += `  and ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '|': code += `  or ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '^': code += `  xor ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            
            // [新增] 移位 (注意：V0是移位数)
            case '<<': code += `  sllv ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break; 
            case '>>': code += `  srlv ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
        }
        return code;
    }
}

// 简单解析器 (更新以支持更多符号)
function simpleParse(source) {
    const statements = [];
    let stackPtr = 8;
    const varMap = {};
    const getOffset = (name) => {
        if (!varMap[name]) { stackPtr+=4; varMap[name] = stackPtr; }
        return varMap[name];
    };

    source.split('\n').forEach(line => {
        line = line.trim();
        // 简易匹配：int a = b + c;
        if (line.startsWith('int ')) {
            const parts = line.match(/int\s+(\w+)\s*=\s*(.+);/);
            if (parts) {
                const name = parts[1];
                const rhs = parts[2].trim();
                let exprNode;
                
                // [更新] 支持更多的操作符 split
                const opMatch = rhs.match(/([\+\-\*\/\%\^\&\|])/); 
                if (opMatch) {
                    const op = opMatch[1];
                    const [l, r] = rhs.split(op).map(s=>s.trim());
                    exprNode = { 
                        type: 'BinaryExpression', operator: op,
                        left: {type:'Variable', offset: getOffset(l)},
                        right:{type:'Variable', offset: getOffset(r)} // 简化：假设右边也是变量
                        // 若右边是数字，需额外判断，这里为了代码简洁暂略
                    };
                } else if (!isNaN(parseInt(rhs))) {
                    exprNode = {type:'Literal', value: parseInt(rhs)};
                } else {
                    exprNode = {type:'Variable', offset: getOffset(rhs)};
                }
                statements.push({ type: 'Assignment', offset: getOffset(name), value: exprNode });
            }
        }
    });
    // 默认返回最后一个变量用于测试
    statements.push({ type: 'ReturnStatement', value: {type:'Literal', value: 0} });

    return { type: 'Program', body: [{
        type: 'FunctionDeclaration', name: 'main', stackSize: 32,
        body: { type: 'Block', statements: statements }
    }]};
}

module.exports = { 
    compile: (source) => {
        const ast = simpleParse(source); 
        const compiler = new MiniCCompiler();
        return compiler.compile(ast); 
    } 
};