/* tools_adapter.js */
window.MiniSys = {};

// ==========================================
// 1. 注入 Mini C 编译器核心
// ==========================================
(function() {
    // [请在此处粘贴 mini_c.js 中除 module.exports 外的所有代码]
    // ... class MiniCCompiler ... class Parser ...
    class MiniCCompiler {
    constructor() {
        this.labelCount = 0;
        this.regs = { ZERO: '$0', V0: '$2', V1: '$3', SP: '$29', TOP: '$30', RA: '$31' };
        this.varMap = {}; 
    }

    newLabel(prefix) { return `L_${prefix}_${this.labelCount++}`; }

    compile(ast) {
        let asm = "# Generated by MiniC Strict Compiler\n";
        // 自动初始化 SP 和 TOP (适配 BIOS)
        // asm += `  lui $sp, 0x0000\n  ori $sp, $sp, 0x7000\n  move $30, $sp\n  j main\n  nop\n`;
        ast.body.forEach(node => asm += this.genNode(node));
        return asm;
    }

    genNode(node) {
        if (!node) return "";
        switch (node.type) {
            case 'Program': return node.body.map(n => this.genNode(n)).join('');
            case 'FunctionDeclaration': return this.genFunction(node);
            case 'Block': return node.statements.map(s => this.genNode(s)).join('');
            case 'ReturnStatement': return this.genReturn(node);
            case 'Assignment': return this.genAssignment(node);
            case 'MemoryWrite': return this.genMemoryWrite(node); 
            case 'IfStatement': return this.genIf(node);
            case 'WhileStatement': return this.genWhile(node);
            case 'BinaryExpression': return this.genBinary(node);
            case 'UnaryExpression': return this.genUnary(node);
            case 'Literal': return `  li ${this.regs.V0}, ${node.value}\n`;
            case 'Variable': 
                if (this.varMap[node.name] === undefined) throw new Error(`Undefined variable: ${node.name}`);
                return `  lw ${this.regs.V0}, ${this.varMap[node.name]}(${this.regs.SP})\n`;
            default: return "";
        }
    }

    genFunction(node) {
        this.varMap = {}; 
        let stackSize = 0;
        
        // 1. 处理变量声明 (规定: 必须在开头)
        node.declarations.forEach(decl => {
            stackSize += 4;
            // 简单数组支持 (int a[10])
            if (decl.size && decl.size > 1) stackSize += (decl.size - 1) * 4;
            this.varMap[decl.name] = stackSize;
        });
        
        stackSize += 8; // RA + Old SP

        const funcName = node.name;
        let code = `\n${funcName}:\n`;
        code += `  sw ${this.regs.RA}, 0(${this.regs.TOP})\n`;
        code += `  sw ${this.regs.SP}, 4(${this.regs.TOP})\n`;
        code += `  move ${this.regs.SP}, ${this.regs.TOP}\n`;
        code += `  addi ${this.regs.TOP}, ${this.regs.TOP}, ${stackSize}\n`;
        
        // 2. 处理语句体
        code += this.genNode(node.body);
        
        code += `  move ${this.regs.TOP}, ${this.regs.SP}\n`;
        code += `  lw ${this.regs.RA}, 0(${this.regs.SP})\n`;
        code += `  lw ${this.regs.SP}, 4(${this.regs.SP})\n`;
        code += `  jr ${this.regs.RA}\n  nop\n`;
        return code;
    }

    genAssignment(node) {
        let code = this.genNode(node.value);
        code += `  sw ${this.regs.V0}, ${this.varMap[node.name]}(${this.regs.SP})\n`;
        return code;
    }

    genMemoryWrite(node) {
        // $addr = val
        let code = this.genNode(node.address); // 计算地址 -> V0
        code += `  sw ${this.regs.V0}, 0(${this.regs.TOP})\n`; // 暂存地址
        code += `  addi ${this.regs.TOP}, ${this.regs.TOP}, 4\n`;
        
        code += this.genNode(node.value); // 计算值 -> V0
        
        code += `  addi ${this.regs.TOP}, ${this.regs.TOP}, -4\n`;
        code += `  lw ${this.regs.V1}, 0(${this.regs.TOP})\n`; // 恢复地址 -> V1
        
        code += `  sw ${this.regs.V0}, 0(${this.regs.V1})\n`; // Store
        return code;
    }

    genIf(node) {
        const labelElse = this.newLabel('else');
        const labelEnd = this.newLabel('ifend');
        let code = this.genNode(node.test);
        code += `  beq ${this.regs.V0}, ${this.regs.ZERO}, ${labelElse}\n  nop\n`;
        code += this.genNode(node.consequent);
        code += `  j ${labelEnd}\n  nop\n`;
        code += `${labelElse}:\n`;
        if (node.alternate) code += this.genNode(node.alternate);
        code += `${labelEnd}:\n`;
        return code;
    }

    genWhile(node) {
        const labelLoop = this.newLabel('loop');
        const labelEnd = this.newLabel('endloop');
        let code = `${labelLoop}:\n`;
        code += this.genNode(node.test);
        code += `  beq ${this.regs.V0}, ${this.regs.ZERO}, ${labelEnd}\n  nop\n`;
        code += this.genNode(node.body);
        code += `  j ${labelLoop}\n  nop\n`;
        code += `${labelEnd}:\n`;
        return code;
    }

    genReturn(node) {
        let code = node.value ? this.genNode(node.value) : "";
        // 恢复栈并返回
        code += `  move ${this.regs.TOP}, ${this.regs.SP}\n`;
        code += `  lw ${this.regs.RA}, 0(${this.regs.SP})\n`;
        code += `  lw ${this.regs.SP}, 4(${this.regs.SP})\n`;
        code += `  jr ${this.regs.RA}\n  nop\n`;
        return code;
    }

    genUnary(node) {
        let code = this.genNode(node.argument);
        switch (node.operator) {
            case '$': // Read MMIO
                code += `  move ${this.regs.V1}, ${this.regs.V0}\n`;
                code += `  lw ${this.regs.V0}, 0(${this.regs.V1})\n`;
                break;
            case '-': code += `  sub ${this.regs.V0}, ${this.regs.ZERO}, ${this.regs.V0}\n`; break;
            case '!': code += `  sltiu ${this.regs.V0}, ${this.regs.V0}, 1\n`; break;
            case '~': code += `  nor ${this.regs.V0}, ${this.regs.V0}, ${this.regs.ZERO}\n`; break;
        }
        return code;
    }

    genBinary(node) {
        let code = this.genNode(node.left);
        code += `  sw ${this.regs.V0}, 0(${this.regs.TOP})\n`; // Push left
        code += `  addi ${this.regs.TOP}, ${this.regs.TOP}, 4\n`;
        code += this.genNode(node.right); // Right -> V0
        code += `  addi ${this.regs.TOP}, ${this.regs.TOP}, -4\n`;
        code += `  lw ${this.regs.V1}, 0(${this.regs.TOP})\n`; // Pop left -> V1
        
        switch (node.operator) {
            case '+': code += `  add ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '-': code += `  sub ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '*': code += `  mult ${this.regs.V1}, ${this.regs.V0}\n  mflo ${this.regs.V0}\n`; break;
            case '&': code += `  and ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '|': code += `  or ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '^': code += `  xor ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '<<': code += `  sllv ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '>>': code += `  srlv ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '<': code += `  slt ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`; break;
            case '>': code += `  slt ${this.regs.V0}, ${this.regs.V0}, ${this.regs.V1}\n`; break;
            case '==': 
                code += `  xor ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`;
                code += `  sltiu ${this.regs.V0}, ${this.regs.V0}, 1\n`;
                break;
            case '!=':
                code += `  xor ${this.regs.V0}, ${this.regs.V1}, ${this.regs.V0}\n`;
                code += `  sltu ${this.regs.V0}, ${this.regs.ZERO}, ${this.regs.V0}\n`;
                break;
        }
        return code;
    }
}

// --- Tokenizer ---
function tokenize(source) {
    // 移除注释
    source = source.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '');
    const regex = /\s*(0x[0-9a-fA-F]+|[0-9]+|int|return|if|else|while|\$|[a-zA-Z_][a-zA-Z0-9_]*|[+\-*/%&|^<>=!~]+|[(){};\[\]])\s*/g;
    let tokens = [];
    let match;
    while ((match = regex.exec(source)) !== null) {
        if (match[1]) tokens.push(match[1]);
    }
    return tokens;
}

// --- Strict Parser ---
class Parser {
    constructor(tokens) { this.tokens = tokens; this.pos = 0; }
    peek() { return this.tokens[this.pos]; }
    consume() { return this.tokens[this.pos++]; }
    match(str) { if (this.peek() === str) { this.pos++; return true; } return false; }
    expect(str) { if (this.consume() !== str) throw new Error(`Expected '${str}' at token ${this.pos}`); }

    parseProgram() {
        let funcs = [];
        // 自动包裹 main 如果没有函数定义 (兼容旧代码)
        if (!this.tokens.includes('void') && !this.tokens.includes('int')) {
             return { type: 'Program', body: [{
                type: 'FunctionDeclaration', name: 'main', 
                declarations: [],
                body: { type: 'Block', statements: this.parseBlockContent() }
            }]};
        }

        while(this.pos < this.tokens.length) {
            // 解析函数: type name() { decls... stmts... }
            this.consume(); // type (void/int)
            let name = this.consume();
            this.expect('('); 
            while(this.peek() !== ')') this.consume(); // 跳过参数
            this.expect(')');
            this.expect('{');
            
            // 1. 严格解析变量声明区
            let decls = [];
            while (this.match('int')) {
                let varName = this.consume();
                let size = 1;
                if (this.match('[')) {
                    size = parseInt(this.consume());
                    this.expect(']');
                }
                // 检查非法初始化
                if (this.peek() === '=') throw new Error(`Illegal Syntax: Variable '${varName}' initialization forbidden in declaration.`);
                this.expect(';');
                decls.push({ name: varName, size });
            }

            // 2. 解析语句区
            let stmts = this.parseBlockContent();
            this.expect('}');
            
            funcs.push({ type: 'FunctionDeclaration', name, declarations: decls, body: { type: 'Block', statements: stmts } });
        }
        return { type: 'Program', body: funcs };
    }

    parseBlockContent() {
        let stmts = [];
        while (this.peek() !== '}' && this.pos < this.tokens.length) {
            if (this.peek() === 'int') throw new Error("Illegal Syntax: Variable declarations must be at the beginning of the function.");
            stmts.push(this.parseStatement());
        }
        return stmts;
    }

    parseStatement() {
        if (this.match('return')) {
            let value = (this.peek() !== ';') ? this.parseExpression() : null;
            this.expect(';');
            return { type: 'ReturnStatement', value };
        }
        if (this.match('if')) {
            this.expect('('); let test = this.parseExpression(); this.expect(')');
            this.expect('{'); let consequent = { type: 'Block', statements: this.parseBlockContent() }; this.expect('}');
            let alternate = null;
            if (this.match('else')) {
                this.expect('{'); alternate = { type: 'Block', statements: this.parseBlockContent() }; this.expect('}');
            }
            return { type: 'IfStatement', test, consequent, alternate };
        }
        if (this.match('while')) {
            this.expect('('); let test = this.parseExpression(); this.expect(')');
            this.expect('{'); let body = { type: 'Block', statements: this.parseBlockContent() }; this.expect('}');
            return { type: 'WhileStatement', test, body };
        }
        
        // 表达式语句
        let expr = this.parseExpression();
        this.expect(';');
        return expr;
    }

    parseExpression() { return this.parseAssignment(); }

    parseAssignment() {
        let left = this.parseLogical();
        if (this.match('=')) {
            let right = this.parseAssignment();
            if (left.type === 'Variable') return { type: 'Assignment', name: left.name, value: right };
            if (left.type === 'UnaryExpression' && left.operator === '$') return { type: 'MemoryWrite', address: left.argument, value: right };
            throw new Error("Invalid l-value assignment");
        }
        return left;
    }

    parseLogical() { return this.parseCompare(); } // 简化优先级
    parseCompare() {
        let left = this.parseAddSub();
        while (['==','!=','<','>'].includes(this.peek())) {
            let op = this.consume();
            let right = this.parseAddSub();
            left = { type: 'BinaryExpression', operator: op, left, right };
        }
        return left;
    }
    parseAddSub() {
        let left = this.parseTerm();
        while (['+','-','|','&','^','<<','>>'].includes(this.peek())) {
            let op = this.consume();
            let right = this.parseTerm();
            left = { type: 'BinaryExpression', operator: op, left, right };
        }
        return left;
    }
    parseTerm() {
        let left = this.parseFactor();
        while (['*','/','%'].includes(this.peek())) {
            let op = this.consume();
            let right = this.parseFactor();
            left = { type: 'BinaryExpression', operator: op, left, right };
        }
        return left;
    }
    parseFactor() {
        if (this.match('(')) { let e = this.parseExpression(); this.expect(')'); return e; }
        if (this.match('$')) return { type: 'UnaryExpression', operator: '$', argument: this.parseFactor() };
        if (this.match('-')) return { type: 'UnaryExpression', operator: '-', argument: this.parseFactor() };
        if (this.match('!')) return { type: 'UnaryExpression', operator: '!', argument: this.parseFactor() };
        if (this.match('~')) return { type: 'UnaryExpression', operator: '~', argument: this.parseFactor() };
        
        let t = this.consume();
        if (/^0x/.test(t)) return { type: 'Literal', value: parseInt(t, 16) };
        if (/^[0-9]+$/.test(t)) return { type: 'Literal', value: parseInt(t) };
        if (/^[a-zA-Z_]/.test(t)) return { type: 'Variable', name: t };
        throw new Error(`Unexpected token: ${t}`);
    }
}
    // 模拟导出
    window.MiniSys.compile = (source) => {
        // 直接调用您 mini_c.js 中的入口函数
        // 假设您的入口是 module.exports.compile
        const tokens = tokenize(source);
        const parser = new Parser(tokens);
        const ast = parser.parseProgram();
        const compiler = new MiniCCompiler();
        return compiler.compile(ast);
    };
})();

// ==========================================
// 2. 注入 汇编器核心 (core.js)
// ==========================================
(function() {
    // [请在此处粘贴 core.js 中除 require('fs') 和 module.exports 外的代码]
    // ... const regMap ... function assemblerCore ...
    // 寄存器映射 (保持不变)
// 寄存器映射
const regMap = {
    zero: 0, at: 1, v0: 2, v1: 3, a0: 4, a1: 5, a2: 6, a3: 7,
    t0: 8,   t1: 9,  t2: 10, t3: 11, t4: 12, t5: 13, t6: 14, t7: 15,
    s0: 16,  s1: 17, s2: 18, s3: 19, s4: 20, s5: 21, s6: 22, s7: 23,
    t8: 24,  t9: 25, k0: 26, k1: 27, gp: 28, sp: 29, fp: 30, ra: 31,
    '$0': 0
};

// 编码工具函数
const encodeR = (rs, rt, rd, shamt, funct) => ((0x00 << 26) | (rs << 21) | (rt << 16) | (rd << 11) | (shamt << 6) | funct) >>> 0;
const encodeI = (op, rs, rt, imm) => ((op << 26) | (rs << 21) | (rt << 16) | (imm & 0xFFFF)) >>> 0;
const encodeJ = (op, addr) => ((op << 26) | (addr & 0x3FFFFFF)) >>> 0;

function parseReg(t) {
    if (!t) return 0;
    const clean = t.replace(/[$,]/g, '').toLowerCase();
    if (regMap[clean] !== undefined) return regMap[clean];
    if (!isNaN(parseInt(clean))) return parseInt(clean);
    return 0;
}

function parseImm(t) {
    if (!t) return 0;
    t = t.trim();
    return t.startsWith('0x') ? parseInt(t, 16) : parseInt(t, 10);
}

function assemblerCore(source) {
    const lines = source.split(/\r?\n/);
    let labels = {};
    let relocations = []; 
    
    // --- 第一遍扫描：计算标签地址 ---
    let tempPc = 0;
    lines.forEach(line => {
        line = line.split('#')[0].trim(); // 去注释
        if (!line) return;
        
        // 处理标签
        if (line.includes(':')) {
            const parts = line.split(':');
            const label = parts[0].trim();
            labels[label] = tempPc;
            line = parts[1].trim(); // 保留标签后的指令
        }
        if (!line) return;
        
        const parts = line.replace(/,/g, ' ').split(/\s+/);
        const op = parts[0].toUpperCase();
        
        // [修复] 忽略伪指令，不增加 PC
        if (op.startsWith('.')) return; 

        // 伪指令特殊处理
        if (op === 'LI') tempPc += 4; 
        else tempPc += 4;
    });

    // --- 第二遍扫描：生成机器码 ---
    let pc = 0;
    let machineCodes = [];

    lines.forEach(line => {
        line = line.split('#')[0].trim();
        if (line.includes(':')) line = line.split(':')[1].trim();
        if (!line) return;

        const parts = line.replace(/,/g, ' ').split(/\s+/);
        const op = parts[0].toUpperCase();

        // [修复] 忽略伪指令
        if (op.startsWith('.')) return;

        let generated = false; // 标记是否生成了指令

        try {
            switch (op) {
                // === 伪指令 ===
                case 'LI': { 
                    const rt = parseReg(parts[1]);
                    const imm = parseImm(parts[2]);
                    machineCodes.push(encodeI(0x09, 0, rt, imm)); 
                    generated = true;
                    break;
                }
                case 'MOVE': { 
                    const rd = parseReg(parts[1]);
                    const rs = parseReg(parts[2]);
                    machineCodes.push(encodeR(rs, 0, rd, 0, 0x21)); 
                    generated = true;
                    break;
                }
                case 'NOP': machineCodes.push(0); generated = true; break;

                // === R-Type ===
                case 'ADD':  machineCodes.push(encodeR(parseReg(parts[2]), parseReg(parts[3]), parseReg(parts[1]), 0, 0x20)); generated = true; break;
                case 'ADDU': machineCodes.push(encodeR(parseReg(parts[2]), parseReg(parts[3]), parseReg(parts[1]), 0, 0x21)); generated = true; break;
                case 'SUB':  machineCodes.push(encodeR(parseReg(parts[2]), parseReg(parts[3]), parseReg(parts[1]), 0, 0x22)); generated = true; break;
                case 'SUBU': machineCodes.push(encodeR(parseReg(parts[2]), parseReg(parts[3]), parseReg(parts[1]), 0, 0x23)); generated = true; break;
                case 'AND':  machineCodes.push(encodeR(parseReg(parts[2]), parseReg(parts[3]), parseReg(parts[1]), 0, 0x24)); generated = true; break;
                case 'OR':   machineCodes.push(encodeR(parseReg(parts[2]), parseReg(parts[3]), parseReg(parts[1]), 0, 0x25)); generated = true; break;
                case 'XOR':  machineCodes.push(encodeR(parseReg(parts[2]), parseReg(parts[3]), parseReg(parts[1]), 0, 0x26)); generated = true; break;
                case 'NOR':  machineCodes.push(encodeR(parseReg(parts[2]), parseReg(parts[3]), parseReg(parts[1]), 0, 0x27)); generated = true; break;
                case 'SLT':  machineCodes.push(encodeR(parseReg(parts[2]), parseReg(parts[3]), parseReg(parts[1]), 0, 0x2A)); generated = true; break;
                case 'SLTU': machineCodes.push(encodeR(parseReg(parts[2]), parseReg(parts[3]), parseReg(parts[1]), 0, 0x2B)); generated = true; break;

                // 移位
                case 'SLL':  machineCodes.push(encodeR(0, parseReg(parts[2]), parseReg(parts[1]), parseInt(parts[3]), 0x00)); generated = true; break;
                case 'SRL':  machineCodes.push(encodeR(0, parseReg(parts[2]), parseReg(parts[1]), parseInt(parts[3]), 0x02)); generated = true; break;
                case 'SRA':  machineCodes.push(encodeR(0, parseReg(parts[2]), parseReg(parts[1]), parseInt(parts[3]), 0x03)); generated = true; break;
                case 'SLLV': machineCodes.push(encodeR(parseReg(parts[3]), parseReg(parts[2]), parseReg(parts[1]), 0, 0x04)); generated = true; break;
                case 'SRLV': machineCodes.push(encodeR(parseReg(parts[3]), parseReg(parts[2]), parseReg(parts[1]), 0, 0x06)); generated = true; break;
                case 'SRAV': machineCodes.push(encodeR(parseReg(parts[3]), parseReg(parts[2]), parseReg(parts[1]), 0, 0x07)); generated = true; break;

                // 跳转
                case 'JR':   machineCodes.push(encodeR(parseReg(parts[1]), 0, 0, 0, 0x08)); generated = true; break;
                case 'JALR': machineCodes.push(encodeR(parseReg(parts[1]), 0, parseReg(parts[2])||31, 0, 0x09)); generated = true; break;

                // 乘除 & HILO
                case 'MULT': machineCodes.push(encodeR(parseReg(parts[1]), parseReg(parts[2]), 0, 0, 0x18)); generated = true; break;
                case 'MULTU':machineCodes.push(encodeR(parseReg(parts[1]), parseReg(parts[2]), 0, 0, 0x19)); generated = true; break;
                case 'DIV':  machineCodes.push(encodeR(parseReg(parts[1]), parseReg(parts[2]), 0, 0, 0x1A)); generated = true; break;
                case 'DIVU': machineCodes.push(encodeR(parseReg(parts[1]), parseReg(parts[2]), 0, 0, 0x1B)); generated = true; break;
                case 'MFHI': machineCodes.push(encodeR(0, 0, parseReg(parts[1]), 0, 0x10)); generated = true; break;
                case 'MFLO': machineCodes.push(encodeR(0, 0, parseReg(parts[1]), 0, 0x12)); generated = true; break;
                case 'MTHI': machineCodes.push(encodeR(parseReg(parts[1]), 0, 0, 0, 0x11)); generated = true; break;
                case 'MTLO': machineCodes.push(encodeR(parseReg(parts[1]), 0, 0, 0, 0x13)); generated = true; break;

                // === I-Type ===
                case 'ADDI': machineCodes.push(encodeI(0x08, parseReg(parts[2]), parseReg(parts[1]), parseInt(parts[3]))); generated = true; break;
                case 'ADDIU':machineCodes.push(encodeI(0x09, parseReg(parts[2]), parseReg(parts[1]), parseInt(parts[3]))); generated = true; break;
                case 'ANDI': machineCodes.push(encodeI(0x0C, parseReg(parts[2]), parseReg(parts[1]), parseInt(parts[3]))); generated = true; break;
                case 'ORI':  machineCodes.push(encodeI(0x0D, parseReg(parts[2]), parseReg(parts[1]), parseInt(parts[3]))); generated = true; break;
                case 'XORI': machineCodes.push(encodeI(0x0E, parseReg(parts[2]), parseReg(parts[1]), parseInt(parts[3]))); generated = true; break;
                case 'LUI':  machineCodes.push(encodeI(0x0F, 0, parseReg(parts[1]), parseInt(parts[2]))); generated = true; break;
                case 'SLTI': machineCodes.push(encodeI(0x0A, parseReg(parts[2]), parseReg(parts[1]), parseInt(parts[3]))); generated = true; break;
                case 'SLTIU':machineCodes.push(encodeI(0x0B, parseReg(parts[2]), parseReg(parts[1]), parseInt(parts[3]))); generated = true; break;

                // Load/Store
                case 'LW': case 'LB': case 'LBU': case 'LH': case 'LHU': 
                case 'SW': case 'SB': case 'SH': {
                    const map = { 
                        'LW':0x23, 'LB':0x20, 'LBU':0x24, 'LH':0x21, 'LHU':0x25,
                        'SW':0x2B, 'SB':0x28, 'SH':0x29 
                    };
                    const match = parts[2].match(/(-?\d+|0x[0-9a-fA-F]+)\((\$\w+)\)/);
                    if(match) {
                        machineCodes.push(encodeI(map[op], parseReg(match[2]), parseReg(parts[1]), parseImm(match[1])));
                        generated = true;
                    }
                    break;
                }

                // Branch
                case 'BEQ': 
                case 'BNE': 
                case 'BLEZ': 
                case 'BGTZ': 
                {
                    const label = parts[op.startsWith('B') && parts.length===4 ? 3 : 2]; 
                    relocations.push({ type: op, pc: pc, label: label });
                    
                    let opcode = 0; let rt = 0; let rs = 0;
                    if (op === 'BEQ') { opcode = 0x04; rs = parseReg(parts[1]); rt = parseReg(parts[2]); }
                    else if (op === 'BNE') { opcode = 0x05; rs = parseReg(parts[1]); rt = parseReg(parts[2]); }
                    else if (op === 'BLEZ') { opcode = 0x06; rs = parseReg(parts[1]); rt = 0; }
                    else if (op === 'BGTZ') { opcode = 0x07; rs = parseReg(parts[1]); rt = 0; }

                    machineCodes.push(encodeI(opcode, rs, rt, 0)); 
                    generated = true;
                    break;
                }

                case 'BLTZ': case 'BGEZ': case 'BLTZAL': case 'BGEZAL':
                {
                    const label = parts[2];
                    relocations.push({ type: op, pc: pc, label: label });
                    let rt = 0;
                    if (op === 'BLTZ') rt = 0;
                    if (op === 'BGEZ') rt = 1;
                    if (op === 'BLTZAL') rt = 16;
                    if (op === 'BGEZAL') rt = 17;
                    machineCodes.push(encodeI(0x01, parseReg(parts[1]), rt, 0));
                    generated = true;
                    break;
                }

                // J-Type
                case 'J':   
                case 'JAL': {
                    const label = parts[1];
                    relocations.push({ type: op, pc: pc, label: label });
                    machineCodes.push(encodeJ(op==='J'?0x02:0x03, 0)); 
                    generated = true;
                    break;
                }

                // CP0
                case 'MTC0': machineCodes.push(((0x10 << 26) | (0x04 << 21) | (parseReg(parts[1]) << 16) | (parseImm(parts[2]) << 11)) >>> 0); generated = true; break;
                case 'MFC0': machineCodes.push(((0x10 << 26) | (0x00 << 21) | (parseReg(parts[1]) << 16) | (parseImm(parts[2]) << 11)) >>> 0); generated = true; break;
                case 'ERET': machineCodes.push(0x42000018); generated = true; break;

                default: break;
            }
            // [修复] 只有生成了代码，才增加 PC
            if (generated) pc += 4;
            
        } catch (e) {
            console.error(`Error at line: ${line} - ${e.message}`);
        }
    });

    return { 
        text: machineCodes, 
        symbols: labels, 
        relocations: relocations 
    };
}
    window.MiniSys.assemble = (source) => {
        return assemblerCore(source); // 调用 core.js 的函数
    };
})();

// ==========================================
// 3. 注入 链接器核心 (linker.js)
// ==========================================
(function() {
    // [请在此处粘贴 linker.js 中除 module.exports 外的代码]
    // ... const LAYOUT ... function linker ...
    const LAYOUT = {
    BIOS_BASE: 0x00000000,
    USER_BASE: 0x00000400, // 给 BIOS 预留 1K 字空间
    ISR_BASE:  0x00000008  // 特殊处理：ISR 的跳转指令通常直接链接在 BIOS 开头
};

function linker(biosObj, userObj, isrObj) {
    // A. 符号全局化：将各段符号映射到物理地址
    const globalSymbols = {};
    
    const lift = (obj, base) => {
        Object.keys(obj.symbols || {}).forEach(label => {
            globalSymbols[label] = obj.symbols[label] + (base * 4); // 转为字节地址
        });
    };

    lift(biosObj, LAYOUT.BIOS_BASE);
    lift(userObj, LAYOUT.USER_BASE);
    // 注意：ISR 通常作为一个函数由 BIOS 的 0x08 地址处跳转进入
    lift(isrObj, LAYOUT.USER_BASE + userObj.text.length); 

    // B. 内存镜像初始化
    const imageSize = 0x4000; // 16K Words
    let image = new Array(imageSize).fill(0);

    // C. 代码段合并
    const writeToImg = (text, base) => {
        for (let i = 0; i < text.length; i++) {
            image[base + i] = text[i] >>> 0;
        }
    };

    writeToImg(biosObj.text, LAYOUT.BIOS_BASE);
    writeToImg(userObj.text, LAYOUT.USER_BASE);
    writeToImg(isrObj.text, LAYOUT.USER_BASE + userObj.text.length);

    // D. 全局重定位回填 (关键修改)
    const allRelocs = [
        ...applyOffset(biosObj.relocations, LAYOUT.BIOS_BASE),
        ...applyOffset(userObj.relocations, LAYOUT.USER_BASE),
        ...applyOffset(isrObj.relocations, LAYOUT.USER_BASE + userObj.text.length)
    ];

    allRelocs.forEach(reloc => {
        const targetAddr = globalSymbols[reloc.label];
        if (targetAddr === undefined) throw new Error(`Undefined symbol: ${reloc.label}`);

        let word = image[reloc.pc / 4];
        
        if (reloc.type === 'J' || reloc.type === 'JAL') {
            // MIPS J-Type: op(6) + target(26). target 为字节地址 >> 2
            word = (word & 0xFC000000) | ((targetAddr >> 2) & 0x3FFFFFF);
        } else if (reloc.type === 'BEQ' || reloc.type === 'BNE') {
            // I-Type: 相对偏移 = (目标 - (当前+4)) / 4
            const offset = (targetAddr - (reloc.pc + 4)) >> 2;
            word = (word & 0xFFFF0000) | (offset & 0xFFFF);
        }
        
        image[reloc.pc / 4] = word >>> 0;
    });

    return image;
}

function applyOffset(relocs, baseWordAddr) {
    return (relocs || []).map(r => ({
        ...r,
        pc: r.pc + (baseWordAddr * 4) // 将 PC 转换为全局字节地址
    }));
}
    window.MiniSys.link = (biosObj, userObj, isrObj) => {
        return linker(biosObj, userObj, isrObj); // 调用 linker.js 的函数
    };
})();